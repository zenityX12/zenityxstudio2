import { useAuth } from "@/_core/hooks/useAuth";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { APP_LOGO, APP_TITLE, getLoginUrl } from "@/const";
import { trpc } from "@/lib/trpc";
import { 
  Coins, Image as ImageIcon, Video, Loader2, Download, Gift, Trash2, 
  Share2, Heart, Copy, ZoomIn, Maximize2, RefreshCw, Sparkles
} from "lucide-react";
import { useState, useEffect, useRef } from "react";

// Helper function to format credits (remove .0 if whole number)
const formatCredits = (value: number | string): string => {
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) return '0';
  return num % 1 === 0 ? num.toString() : num.toFixed(1);
};
import { Link, useLocation } from "wouter";
import { toast } from "sonner";
import { ImageViewer } from "@/components/ImageViewer";
import { PromptTemplates } from "@/components/PromptTemplates";
import { PromptHistory } from "@/components/PromptHistory";
import { Sora2Tab } from "@/components/Sora2Tab";
import { Veo3Tab } from "@/components/Veo3Tab";
import { SeedanceTab } from "@/components/SeedanceTab";
import { ImageUploadBox } from "@/components/ImageUploadBox";
import { UserMenu } from "@/components/UserMenu";
import { Logo } from "@/components/Logo";
import { Sidebar } from "@/components/Sidebar";
// @ts-ignore - no types available
import Masonry from "react-masonry-css";
import { ChevronLeft, ChevronRight, Grid3x3, LayoutGrid, LayoutList } from "lucide-react";

export default function Studio() {
  const { user, isAuthenticated } = useAuth();
  const [location] = useLocation();
  
  // Get tab from URL query parameter
  const urlParams = new URLSearchParams(location.split('?')[1] || '');
  const tabFromUrl = urlParams.get('tab') || 'image';
  
  const [sidebarCollapsed, setSidebarCollapsed] = useState(() => {
    const saved = localStorage.getItem("sidebarCollapsed");
    return saved ? JSON.parse(saved) : false;
  });
  const [prompt, setPrompt] = useState("");
  const [negativePrompt, setNegativePrompt] = useState("");
  const [selectedModel, setSelectedModel] = useState<string>("");
  const [currentTab, setCurrentTab] = useState<string>(tabFromUrl);
  const [imageSubTab, setImageSubTab] = useState<string>("seedream"); // seedream, nano-banana, ideogram
  const [videoSubTab, setVideoSubTab] = useState<string>("sora2"); // sora2, veo, seedance
  const [imageModel, setImageModel] = useState<string>("");
  const [sora2Model, setSora2Model] = useState<string>("");
  const [veoModel, setVeoModel] = useState<string>("");
  const [seedanceModel, setSeedanceModel] = useState<string>("");
  const [viewSize, setViewSize] = useState<"compact" | "comfortable" | "spacious">("comfortable");
  const [currentPage, setCurrentPage] = useState(1);
  // View-based pagination: Spacious (10), Comfortable (15), Compact (25)
  const itemsPerPage = viewSize === "spacious" ? 10 : viewSize === "comfortable" ? 15 : 25;
  const [inviteCode, setInviteCode] = useState("");
  const [inviteDialogOpen, setInviteDialogOpen] = useState(false);
  const [viewerOpen, setViewerOpen] = useState(false);
  const [viewerImage, setViewerImage] = useState({ src: "", alt: "" });
  const [aspectRatio, setAspectRatio] = useState("1:1");
  const [imageResolution, setImageResolution] = useState<"1K" | "2K" | "4K">("1K");
  const [videoAspectRatio, setVideoAspectRatio] = useState<"16:9" | "9:16" | "Auto">("16:9");
  const [videoGenerationType, setVideoGenerationType] = useState<"TEXT_2_VIDEO" | "FIRST_AND_LAST_FRAMES_2_VIDEO" | "REFERENCE_2_VIDEO">("TEXT_2_VIDEO");
  const [uploadedImageUrls, setUploadedImageUrls] = useState<string[]>([]);
  const [imageUploadFiles, setImageUploadFiles] = useState<File[]>([]);
  const [imageUploadPreviews, setImageUploadPreviews] = useState<string[]>([]);
  const [isImageUploading, setIsImageUploading] = useState(false);
  const [isVeoImageUploading, setIsVeoImageUploading] = useState(false);
  const [veoUploadedFiles, setVeoUploadedFiles] = useState<File[]>([]);
  const [promptHistory, setPromptHistory] = useState<Array<{
    id: string;
    prompt: string;
    timestamp: Date;
    modelName: string;
  }>>([]);
  
  // Image Tab - New features
  const [outputFormat, setOutputFormat] = useState<"png" | "jpeg">("png");
  const [maxImages, setMaxImages] = useState<number>(1); // Seedream V4: 1-4
  const [numImages, setNumImages] = useState<"1" | "2" | "3" | "4">("1"); // Ideogram: 1-4
  const [referenceImageFiles, setReferenceImageFiles] = useState<File[]>([]);
  const [referenceImageUrls, setReferenceImageUrls] = useState<string[]>([]);
  const [renderingSpeed, setRenderingSpeed] = useState<"TURBO" | "BALANCED" | "QUALITY">("BALANCED");
  const [style, setStyle] = useState<"AUTO" | "REALISTIC" | "FICTION">("AUTO");
  const [expandPrompt, setExpandPrompt] = useState<boolean>(true); // Default true per API docs
  const [strength, setStrength] = useState<number>(0.8);
  const [imageUrl, setImageUrl] = useState<string | undefined>(undefined); // For Character Remix
  const imageUrlRef = useRef<string | undefined>(undefined); // Ref to avoid closure problem
  const [styleImageFiles, setStyleImageFiles] = useState<File[]>([]);

  // Debug: Track imageUrl changes and sync with ref
  useEffect(() => {
    console.log('[State] imageUrl changed to:', imageUrl);
    imageUrlRef.current = imageUrl; // Sync ref with state
  }, [imageUrl]);
  const [styleImageUrls, setStyleImageUrls] = useState<string[]>([]);
  const [isReferenceImageUploading, setIsReferenceImageUploading] = useState(false);
  const [isStyleImageUploading, setIsStyleImageUploading] = useState(false);

  const { data: credits = 0 } = trpc.credits.get.useQuery(undefined, {
    enabled: isAuthenticated,
  });

  const { data: models = [] } = trpc.models.list.useQuery();
  const { data: generations = [] } = trpc.generations.list.useQuery(undefined, {
    enabled: isAuthenticated,
    refetchInterval: 5000,
  });

  // Debug: Log generations data
  useEffect(() => {
    if (generations.length > 0) {
      console.log('[Debug] Generations data:', generations);
      console.log('[Debug] First generation:', generations[0]);
      console.log('[Debug] First generation taskId:', generations[0].taskId);
    }
  }, [generations]);

  // Auto-select models for each tab
  useEffect(() => {
    if (models.length === 0) return;

    // Filter to show only base models (exclude edit variants from dropdown)
    // Edit models will be used automatically when images are uploaded
    const imageModels = models.filter((m) => 
      m.type === "image" && 
      !m.modelId?.includes("-edit") && 
      !m.modelId?.includes("Edit")
    );
    // Filter Sora 2 models - only show text-to-video base models (exclude image-to-video variants)
    const sora2Models = models.filter((m) => 
      m.type === "video" && 
      m.modelId?.startsWith("sora") && 
      !m.modelId?.includes("image-to-video") &&
      m.isActive
    );
    const veoModels = models.filter((m) => m.type === "video" && m.modelId?.startsWith("veo"));
    const seedanceModels = models.filter((m) => 
      m.type === "video" && m.modelId?.startsWith("bytedance/v1")
    );

    // Auto-select from last generation or first model
    if (!imageModel && imageModels.length > 0) {
      const lastImageGen = generations.find(g => {
        const model = models.find(m => m.id === g.modelId);
        return model?.type === "image" && !model.modelId?.includes("-edit");
      });
      setImageModel(lastImageGen?.modelId || imageModels[0].id);
    }

    if (!sora2Model && sora2Models.length > 0) {
      const lastSora2Gen = generations.find(g => {
        const model = models.find(m => m.id === g.modelId);
        return model?.modelId?.startsWith("sora");
      });
      setSora2Model(lastSora2Gen?.modelId || sora2Models[0].id);
    }

    if (!veoModel && veoModels.length > 0) {
      const lastVeoGen = generations.find(g => {
        const model = models.find(m => m.id === g.modelId);
        return model?.modelId?.startsWith("veo");
      });
      setVeoModel(lastVeoGen?.modelId || veoModels[0].id);
    }

    if (!seedanceModel && seedanceModels.length > 0) {
      const lastSeedanceGen = generations.find(g => {
        const model = models.find(m => m.id === g.modelId);
        return model?.modelId?.startsWith("bytedance/v1");
      });
      setSeedanceModel(lastSeedanceGen?.modelId || seedanceModels[0].id);
    }
  }, [models, generations, imageModel, sora2Model, veoModel, seedanceModel]);

  // Auto-select model based on imageSubTab
  useEffect(() => {
    if (currentTab === "image" && models.length > 0) {
      if (imageSubTab === "seedream") {
        const seedreamModel = models.find(m => m.modelId === "seedream-v4-text-to-image");
        if (seedreamModel) {
          setImageModel(seedreamModel.id);
          setSelectedModel(seedreamModel.id);
        }
      } else if (imageSubTab === "nano-banana") {
        const nanoBananaModel = models.find(m => m.modelId === "nano-banana");
        if (nanoBananaModel) {
          setImageModel(nanoBananaModel.id);
          setSelectedModel(nanoBananaModel.id);
        }
      }
      // For ideogram, let user select manually
    }
  }, [imageSubTab, currentTab, models]);

  // Sync selectedModel with current tab and sub-tabs
  useEffect(() => {
    if (currentTab === "image") {
      setSelectedModel(imageModel);
    } else if (currentTab === "video") {
      if (videoSubTab === "sora2") {
        setSelectedModel(sora2Model);
      } else if (videoSubTab === "veo") {
        setSelectedModel(veoModel);
      } else if (videoSubTab === "seedance") {
        setSelectedModel(seedanceModel);
      }
    }
  }, [currentTab, videoSubTab, imageModel, sora2Model, veoModel, seedanceModel]);

  const utils = trpc.useUtils();
  const uploadMutation = trpc.upload.useMutation();

  // Save sidebar collapsed state
  useEffect(() => {
    localStorage.setItem("sidebarCollapsed", JSON.stringify(sidebarCollapsed));
  }, [sidebarCollapsed]);

  const toggleSidebar = () => {
    setSidebarCollapsed(!sidebarCollapsed);
  };

  // Load prompt history from localStorage
  useEffect(() => {
    const saved = localStorage.getItem("promptHistory");
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        setPromptHistory(parsed.map((item: any) => ({
          ...item,
          timestamp: new Date(item.timestamp),
        })));
      } catch (e) {
        console.error("Failed to parse prompt history:", e);
      }
    }
  }, []);

  // Save prompt history to localStorage
  const saveToHistory = (prompt: string, modelId: string) => {
    const model = models.find(m => m.id === modelId);
    if (!model) return;

    const newItem = {
      id: Date.now().toString(),
      prompt,
      timestamp: new Date(),
      modelName: model.name,
    };

    const updated = [newItem, ...promptHistory].slice(0, 50); // Keep last 50
    setPromptHistory(updated);
    localStorage.setItem("promptHistory", JSON.stringify(updated));
  };

  const createMutation = trpc.generations.create.useMutation({
    onSuccess: () => {
      toast.success("Generation started!");
      if (prompt && selectedModel) {
        saveToHistory(prompt, selectedModel);
      }
      // Keep prompt for easy re-generation
      // setPrompt("");
      // setNegativePrompt("");
      utils.generations.list.invalidate();
      utils.credits.get.invalidate();
    },
    onError: (error) => {
      toast.error(error.message);
    },
  });

  const deleteMutation = trpc.generations.delete.useMutation({
    onSuccess: () => {
      toast.success("Generation deleted");
      utils.generations.list.invalidate();
    },
    onError: (error) => {
      toast.error(error.message);
    },
  });

  const get1080pMutation = trpc.generations.get1080p.useMutation({
    onSuccess: (data) => {
      window.open(data.url, "_blank");
      toast.success("1080P video ready!");
    },
    onError: (error) => {
      toast.error(error.message || "Failed to get 1080P video");
    },
  });

  const redeemMutation = trpc.redeemInvite.useMutation({
    onSuccess: (data: { credits: number }) => {
      toast.success(`Redeemed! You received ${data.credits} credits`);
      setInviteCode("");
      setInviteDialogOpen(false);
      utils.credits.get.invalidate();
    },
    onError: (error: any) => {
      toast.error(error.message);
    },
  });

  const handleRedeemInvite = () => {
    if (!inviteCode.trim()) {
      toast.error("Please enter an invite code");
      return;
    }
    redeemMutation.mutate({ code: inviteCode });
  };

  const handleGenerate = async () => {
    if (!selectedModel || !prompt.trim()) {
      toast.error("Please select a model and enter a prompt");
      return;
    }

    let actualModelId = selectedModel;
    let imageUrl: string | undefined = undefined;

    // Handle Seedream V4 and Google Nano Banana automatic model selection
    const model = models.find(m => m.id === selectedModel);
    const isSeedreamV4 = model?.modelId?.startsWith("bytedance/seedream-v4");
    const isGoogleNanoBanana = model?.modelId?.startsWith("google/nano-banana");
    const isCharacterRemix = model?.modelId === 'ideogram/character-remix';
    let imageUrls: string[] = [];
    
    console.log('[Generate] Model:', model?.name, model?.modelId);
    console.log('[Generate] isSeedreamV4:', isSeedreamV4);
    console.log('[Generate] isGoogleNanoBanana:', isGoogleNanoBanana);
    console.log('[Generate] imageUrl (state):', imageUrl);
    console.log('[Generate] imageUrl (ref):', imageUrlRef.current);
    console.log('[Generate] imageUploadFiles.length:', imageUploadFiles.length);
    
    const currentImageUrl = imageUrlRef.current; // Use ref to get latest value
    
    if ((isSeedreamV4 || isGoogleNanoBanana || isCharacterRemix) && (imageUploadFiles.length > 0 || currentImageUrl)) {
      // Use existing imageUrl if no new files to upload
      if (currentImageUrl && imageUploadFiles.length === 0) {
        imageUrls = [currentImageUrl];
        console.log('[Generate] Using existing imageUrl:', currentImageUrl);
      } else if (imageUploadFiles.length > 0) {
        // Upload images first
        toast.info(`Uploading ${imageUploadFiles.length} image(s)...`);
        
        try {
          const uploadPromises = imageUploadFiles.map(async (file) => {
            // Convert file to base64
            const reader = new FileReader();
            const base64 = await new Promise<string>((resolve) => {
              reader.onloadend = () => {
                const result = reader.result as string;
                resolve(result.split(',')[1]); // Remove data:image/...;base64, prefix
              };
              reader.readAsDataURL(file);
            });
            
            // Upload via tRPC
            const result = await uploadMutation.mutateAsync({
              file: base64,
              filename: file.name,
              contentType: file.type,
            });
            
            return result.url;
          });
          
          imageUrls = await Promise.all(uploadPromises);
        } catch (error) {
          console.error('[Upload] Error:', error);
          toast.error("Failed to upload images");
          return;
        }
      }
      
      // Switch to edit model if images are present (either from URL or upload)
      if (isSeedreamV4) {
        const editModel = models.find(m => m.modelId === "bytedance/seedream-v4-edit");
        if (editModel) {
          actualModelId = editModel.id;
          console.log('[Generate] Switched to Seedream V4 Edit model');
        }
      } else if (isGoogleNanoBanana) {
        const editModel = models.find(m => m.modelId === "google/nano-banana-edit");
        if (editModel) {
          actualModelId = editModel.id;
          console.log('[Generate] Switched to Nano Banana Edit model');
        }
      }
        
      // Note: Seedream V4 Edit uses imageUrls array, not imageUrl string
    }

    const isVeo3 = model?.modelId === "veo3" || model?.modelId === "veo3_fast";

    // Validate image requirements for different generation types
    if (isVeo3 && videoGenerationType !== "TEXT_2_VIDEO") {
      if (uploadedImageUrls.length === 0) {
        toast.error("Please upload at least one image for this generation type");
        return;
      }
      if (videoGenerationType === "FIRST_AND_LAST_FRAMES_2_VIDEO" && uploadedImageUrls.length > 2) {
        toast.error("Maximum 2 images allowed for First-and-Last-Frames mode");
        return;
      }
      if (videoGenerationType === "REFERENCE_2_VIDEO" && uploadedImageUrls.length > 3) {
        toast.error("Maximum 3 images allowed for Reference mode");
        return;
      }
    }

    // Handle Ideogram reference image upload
    const isIdeogramModel = model?.modelId?.startsWith('ideogram/');
    let uploadedReferenceUrls: string[] = [...referenceImageUrls]; // Start with existing URLs
    
    if (isIdeogramModel && referenceImageFiles.length > 0) {
      // Upload reference images first
      toast.info(`Uploading ${referenceImageFiles.length} reference image(s)...`);
      
      try {
        const uploadPromises = referenceImageFiles.map(async (file) => {
          // Convert file to base64
          const reader = new FileReader();
          const base64 = await new Promise<string>((resolve) => {
            reader.onloadend = () => {
              const result = reader.result as string;
              resolve(result.split(',')[1]); // Remove data:image/...;base64, prefix
            };
            reader.readAsDataURL(file);
          });
          
          // Upload via tRPC
          const result = await uploadMutation.mutateAsync({
            file: base64,
            filename: file.name,
            contentType: file.type,
          });
          
          return result.url;
        });
        
        const newUrls = await Promise.all(uploadPromises);
        uploadedReferenceUrls = [...uploadedReferenceUrls, ...newUrls];
        console.log('[Generate] Uploaded reference images:', uploadedReferenceUrls);
      } catch (error) {
        console.error('[Upload] Reference image error:', error);
        toast.error("Failed to upload reference images");
        return;
      }
    }
    
    // Check Ideogram model requirements
    if (isIdeogramModel && uploadedReferenceUrls.length === 0) {
      toast.error("Please upload a character reference image for Ideogram models");
      return;
    }

    // Validate Character Remix requires image_url
    if (isCharacterRemix && imageUrls.length === 0 && !imageUrl) {
      toast.error("Please upload an image to remix for Character Remix model");
      return;
    }

    createMutation.mutate({
      modelId: actualModelId,
      prompt: prompt.trim(),
      ...(!isVeo3 && { aspectRatio: aspectRatio }),
      ...(imageUrls.length > 0 && (isSeedreamV4 || isGoogleNanoBanana) && { imageUrls: imageUrls }),
      // Add Seedream V4 parameters
      ...(isSeedreamV4 && { 
        imageResolution: imageResolution,
        maxImages: maxImages,
      }),
      // Add Nano Banana parameters
      ...(isGoogleNanoBanana && {
        outputFormat: outputFormat,
      }),
      // Add Ideogram parameters
      ...(isIdeogramModel && {
        referenceImageUrls: uploadedReferenceUrls,
        renderingSpeed: renderingSpeed,
        style: style,
        expandPrompt: expandPrompt,
        numImages: numImages,
        negativePrompt: negativePrompt,
        ...(model?.modelId === 'ideogram/character-remix' && {
          imageUrl: imageUrl || imageUrls[0], // Use imageUrl state if available (from Reuse), otherwise from upload
          strength: strength,
          ...(styleImageUrls.length > 0 && { styleImageUrls: styleImageUrls }),
        }),
      }),
      // Add Veo 3.1 parameters if applicable
      ...(isVeo3 && {
        aspectRatio: videoAspectRatio,
        generationType: videoGenerationType,
        imageUrls: uploadedImageUrls.length > 0 ? uploadedImageUrls : undefined,
      }),
    });

    // Keep image upload files for re-generation

    // Save to history
    saveToHistory(prompt.trim(), actualModelId);
  };

  const handleShare = async (url: string, prompt: string) => {
    try {
      if (navigator.share) {
        await navigator.share({
          title: prompt,
          url: url,
        });
      } else {
        await navigator.clipboard.writeText(url);
        toast.success("Link copied to clipboard");
      }
    } catch (error) {
      console.error("Share failed:", error);
    }
  };

  const handleCopyPrompt = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("Prompt copied to clipboard");
  };

  const handleViewImage = (src: string, alt: string) => {
    setViewerImage({ src, alt });
    setViewerOpen(true);
  };

  const imageModels = models.filter((m) => m.type === "image" && !m.modelId?.includes("-edit"));
  const sora2Models = models.filter((m) => m.type === "video" && m.modelId?.startsWith("sora"));
  const veoModels = models.filter((m) => m.type === "video" && m.modelId?.startsWith("veo"));
  const seedanceModels = models.filter((m) => m.type === "video" && m.modelId?.startsWith("bytedance/v1"));

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100">
        <Card className="max-w-md w-full">
          <CardHeader className="text-center">
            <CardTitle>Sign In Required</CardTitle>
            <CardDescription>Please sign in to access the studio</CardDescription>
          </CardHeader>
          <CardContent>
            <Button asChild className="w-full">
              <a href={getLoginUrl()}>Sign In</a>
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100">
      {/* Sidebar */}
      <Sidebar isCollapsed={sidebarCollapsed} onToggle={toggleSidebar} />

      {/* Main Content */}
      <div
        className="transition-all duration-300 ease-in-out"
        style={{
          marginLeft: sidebarCollapsed ? "4rem" : "16rem",
        }}
      >
        {/* Header */}
        <header className="border-b bg-white/80 backdrop-blur-sm sticky top-0 z-10">
          <div className="container mx-auto px-4 h-16 flex items-center justify-between">
            <div></div>
            <div className="flex items-center gap-4">
              <div className="flex items-center gap-2 px-4 py-2 bg-gray-100 rounded-lg">
                <Coins className="h-5 w-5 text-yellow-600" />
                <span className="font-semibold">{credits}</span>
                <span className="text-sm text-muted-foreground">credits</span>
              </div>

              <Dialog open={inviteDialogOpen} onOpenChange={setInviteDialogOpen}>
                <DialogTrigger asChild>
                  <Button variant="outline" size="sm" className="gap-2">
                    <Gift className="h-4 w-4" />
                    Redeem Code
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Redeem Code</DialogTitle>
                    <DialogDescription>
                      Enter your code to receive credits
                    </DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <Input
                      placeholder="Enter code"
                      value={inviteCode}
                      onChange={(e) => setInviteCode(e.target.value)}
                    />
                  </div>
                  <DialogFooter>
                    <Button
                      onClick={handleRedeemInvite}
                      disabled={redeemMutation.isPending}
                    >
                      {redeemMutation.isPending ? "Redeeming..." : "Redeem"}
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>

              {user?.role === "admin" && (
                <Link href="/admin">
                  <Button variant="outline" size="sm">Admin</Button>
                </Link>
              )}

              <UserMenu />
            </div>
          </div>
        </header>

        <div className="container mx-auto px-4 py-8">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
            {/* Generation Form */}
            <div className="lg:col-span-1">
            {/* Image Generator */}
            {currentTab === "image" && (
              <Card>
                <CardHeader>
                  <CardTitle>Generate Image</CardTitle>
                  <CardDescription>
                    Create stunning images with AI
                  </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                  {/* Image Sub-tabs at top */}
                  <Tabs value={imageSubTab} onValueChange={setImageSubTab} className="w-full">
                    <TabsList className="grid w-full grid-cols-3">
                      <TabsTrigger value="seedream">Seedream V4</TabsTrigger>
                      <TabsTrigger value="nano-banana">Nano Banana</TabsTrigger>
                      <TabsTrigger value="ideogram">Ideogram</TabsTrigger>
                    </TabsList>
                  </Tabs>
                    
                    {/* Model selector - only show for Ideogram (has 2 models: Character and Character Remix) */}
                    {imageSubTab === "ideogram" && (
                      <div className="space-y-2">
                        <Label>Model</Label>
                        <Select value={imageModel} onValueChange={(value) => {
                          setImageModel(value);
                          setSelectedModel(value);
                        }}>
                          <SelectTrigger>
                            <SelectValue placeholder="Select a model">
                              {imageModel && imageModels.find(m => m.id === imageModel)?.name}
                            </SelectValue>
                          </SelectTrigger>
                          <SelectContent>
                            {imageModels.filter(m => m.modelId?.startsWith('ideogram/')).map((model) => (
                              <SelectItem key={model.id} value={model.id}>
                                {model.name}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                    )}

                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <Label>Prompt</Label>
                        <div className="flex gap-2">
                          <PromptHistory
                            history={promptHistory}
                            onSelectPrompt={setPrompt}
                            onClearHistory={() => {
                              setPromptHistory([]);
                              localStorage.removeItem("promptHistory");
                              toast.success("History cleared");
                            }}
                          />
                          <PromptTemplates
                            onSelectTemplate={setPrompt}
                            type="image"
                          />
                        </div>
                      </div>
                      <Textarea
                        placeholder="Describe what you want to create..."
                        value={prompt}
                        onChange={(e) => setPrompt(e.target.value)}
                        rows={4}
                      />
                    </div>

                    {/* Hide Image Upload for Ideogram Character and Character Remix (they have their own specific upload boxes) */}
                    {selectedModel && models.find(m => m.id === selectedModel)?.modelId !== 'ideogram/character' && models.find(m => m.id === selectedModel)?.modelId !== 'ideogram/character-remix' && (
                      <ImageUploadBox
                        maxImages={10}
                        maxSizeMB={10}
                        uploadedFiles={imageUploadFiles}
                        onFilesChange={setImageUploadFiles}
                        initialUrls={imageUrl ? [imageUrl] : []}
                        onUrlsRemove={(urls) => {
                          if (urls.length === 0) {
                            setImageUrl("");
                          }
                        }}
                        onUpload={async (files) => {
                          setIsImageUploading(true);
                          try {
                            const uploadPromises = files.map(async (file) => {
                              // Convert file to base64
                              const reader = new FileReader();
                              const base64 = await new Promise<string>((resolve) => {
                                reader.onloadend = () => {
                                  const result = reader.result as string;
                                  resolve(result.split(',')[1]); // Remove data:image/...;base64, prefix
                                };
                                reader.readAsDataURL(file);
                              });
                              
                              // Upload via tRPC
                              const result = await uploadMutation.mutateAsync({
                                file: base64,
                                filename: file.name,
                                contentType: file.type,
                              });
                              
                              return result.url;
                            });

                            const urls = await Promise.all(uploadPromises);
                            return urls;
                          } finally {
                            setIsImageUploading(false);
                          }
                        }}
                        isUploading={isImageUploading}
                        label="Image Upload"
                        description="Optional, for image editing models"
                      />
                    )}

                    <div className="space-y-2">
                      <Label>Aspect Ratio</Label>
                      <Select value={aspectRatio} onValueChange={setAspectRatio}>
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="1:1">Square (1:1)</SelectItem>
                          <SelectItem value="square_hd">Square HD</SelectItem>
                          <SelectItem value="16:9">Landscape (16:9)</SelectItem>
                          <SelectItem value="9:16">Portrait (9:16)</SelectItem>
                          <SelectItem value="4:3">Landscape (4:3)</SelectItem>
                          <SelectItem value="3:4">Portrait (3:4)</SelectItem>
                          <SelectItem value="3:2">Landscape (3:2)</SelectItem>
                          <SelectItem value="2:3">Portrait (2:3)</SelectItem>
                          <SelectItem value="21:9">Landscape (21:9)</SelectItem>
                          <SelectItem value="5:4">Landscape (5:4)</SelectItem>
                          <SelectItem value="4:5">Portrait (4:5)</SelectItem>
                          <SelectItem value="auto">Auto</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>

                    {/* Image Resolution for Seedream V4 */}
                    {selectedModel && models.find(m => m.id === selectedModel)?.modelId?.includes('seedream-v4') && (
                      <div className="space-y-2">
                        <Label>Image Resolution</Label>
                        <Select value={imageResolution} onValueChange={(value: "1K" | "2K" | "4K") => setImageResolution(value)}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="1K">1K (Fast)</SelectItem>
                            <SelectItem value="2K">2K (Balanced)</SelectItem>
                            <SelectItem value="4K">4K (High Quality)</SelectItem>
                          </SelectContent>
                        </Select>
                        <p className="text-xs text-muted-foreground">
                          Higher resolution produces better quality but costs more credits
                        </p>
                      </div>
                    )}

                    {/* Batch Generation for Seedream V4 */}
                    {selectedModel && models.find(m => m.id === selectedModel)?.modelId?.includes('seedream-v4') && (
                      <div className="space-y-2">
                        <Label>Number of Images</Label>
                        <Select value={String(maxImages)} onValueChange={(value) => setMaxImages(Number(value))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            {[1, 2, 3, 4].map(num => (
                              <SelectItem key={num} value={String(num)}>
                                {num} {num > 1 ? 'images' : 'image'}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <p className="text-xs text-muted-foreground">
                          Generate multiple images at once. Cost: {maxImages}Ã— base price
                        </p>
                      </div>
                    )}

                    {/* Output Format for Nano Banana */}
                    {selectedModel && models.find(m => m.id === selectedModel)?.modelId?.includes('nano-banana') && (
                      <div className="space-y-2">
                        <Label>Output Format</Label>
                        <Select value={outputFormat} onValueChange={(value: "png" | "jpeg") => setOutputFormat(value)}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="png">PNG (Lossless)</SelectItem>
                            <SelectItem value="jpeg">JPEG (Smaller file size)</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                    )}

                    {/* Ideogram Character Remix - Image Upload (Required) */}
                    {selectedModel && models.find(m => m.id === selectedModel)?.modelId === 'ideogram/character-remix' && (
                      <div className="space-y-2">
                        <Label>Image to Remix (Required)</Label>
                        <ImageUploadBox
                          maxImages={1}
                          maxSizeMB={10}
                          uploadedFiles={imageUploadFiles}
                          onFilesChange={setImageUploadFiles}
                          initialUrls={imageUrl ? [imageUrl] : []}
                          onUrlsRemove={(urls) => {
                            if (urls.length === 0) {
                              setImageUrl("");
                            }
                          }}
                          onUpload={async (files) => {
                            setIsImageUploading(true);
                            try {
                              const uploadPromises = files.map(async (file) => {
                                const reader = new FileReader();
                                const base64 = await new Promise<string>((resolve) => {
                                  reader.onloadend = () => {
                                    const result = reader.result as string;
                                    resolve(result.split(',')[1]);
                                  };
                                  reader.readAsDataURL(file);
                                });
                                
                                const result = await uploadMutation.mutateAsync({
                                  file: base64,
                                  filename: file.name,
                                  contentType: file.type,
                                });
                                
                                return result.url;
                              });

                              const urls = await Promise.all(uploadPromises);
                              return urls;
                            } finally {
                              setIsImageUploading(false);
                            }
                          }}
                          isUploading={isImageUploading}
                          label="Upload Image to Remix"
                          description="Upload the base image you want to remix (required)"
                        />
                      </div>
                    )}

                    {/* Ideogram Models - Character Reference (Both models) */}
                    {selectedModel && models.find(m => m.id === selectedModel)?.modelId?.startsWith('ideogram/') && (
                      <>
                        <div className="space-y-2">
                          <Label>Character Reference (Required)</Label>
                          <ImageUploadBox
                            maxImages={1}
                            maxSizeMB={10}
                            uploadedFiles={referenceImageFiles}
                            onFilesChange={(files) => {
                              setReferenceImageFiles(files);
                              // Clear URL previews when new files are uploaded
                              if (files.length > 0) {
                                setReferenceImageUrls([]);
                              }
                            }}
                            initialUrls={referenceImageUrls}
                            onUrlsRemove={(urls) => {
                              setReferenceImageUrls(urls);
                            }}
                            onUpload={async (files) => {
                              setIsReferenceImageUploading(true);
                              try {
                                const uploadPromises = files.map(async (file) => {
                                  const reader = new FileReader();
                                  const base64 = await new Promise<string>((resolve) => {
                                    reader.onloadend = () => {
                                      const result = reader.result as string;
                                      resolve(result.split(',')[1]);
                                    };
                                    reader.readAsDataURL(file);
                                  });
                                  
                                  const result = await uploadMutation.mutateAsync({
                                    file: base64,
                                    filename: file.name,
                                    contentType: file.type,
                                  });
                                  
                                  return result.url;
                                });

                                const urls = await Promise.all(uploadPromises);
                                setReferenceImageUrls(urls);
                                return urls;
                              } finally {
                                setIsReferenceImageUploading(false);
                              }
                            }}
                            isUploading={isReferenceImageUploading}
                            label="Upload Character Reference"
                            description="Upload a photo of the character you want to use (required, only 1 image)"
                          />
                        </div>

                        <div className="space-y-2">
                          <Label>Rendering Speed</Label>
                          <Select value={renderingSpeed} onValueChange={(value: "TURBO" | "BALANCED" | "QUALITY") => setRenderingSpeed(value)}>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="TURBO">Turbo (Fastest)</SelectItem>
                              <SelectItem value="BALANCED">Balanced</SelectItem>
                              <SelectItem value="QUALITY">Quality (Best)</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>

                        <div className="space-y-2">
                          <Label>Style</Label>
                          <Select value={style} onValueChange={(value: "AUTO" | "REALISTIC" | "FICTION") => setStyle(value)}>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="AUTO">Auto</SelectItem>
                              <SelectItem value="REALISTIC">Realistic</SelectItem>
                              <SelectItem value="FICTION">Fiction</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>

                        <div className="space-y-2">
                          <Label>Number of Images</Label>
                          <Select value={numImages} onValueChange={(value: "1" | "2" | "3" | "4") => setNumImages(value)}>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent>
                              {["1", "2", "3", "4"].map(num => (
                                <SelectItem key={num} value={num}>
                                  {num} {num !== "1" ? 'images' : 'image'}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <p className="text-xs text-muted-foreground">
                            Generate multiple images at once
                          </p>
                        </div>

                        <div className="flex items-center space-x-2">
                          <input
                            type="checkbox"
                            id="expandPrompt"
                            checked={expandPrompt}
                            onChange={(e) => setExpandPrompt(e.target.checked)}
                            className="w-4 h-4 text-primary bg-gray-100 border-gray-300 rounded focus:ring-primary dark:focus:ring-primary dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                          />
                          <Label htmlFor="expandPrompt" className="text-sm font-normal cursor-pointer">
                            Expand Prompt (MagicPrompt)
                          </Label>
                        </div>
                        <p className="text-xs text-muted-foreground -mt-2">
                          Automatically enhance your prompt for better results (recommended)
                        </p>

                        {/* Character Remix Specific - Strength Slider */}
                        {models.find(m => m.id === selectedModel)?.modelId === 'ideogram/character-remix' && (
                          <div className="space-y-2">
                            <Label>Strength: {strength.toFixed(1)}</Label>
                            <input
                              type="range"
                              min="0.1"
                              max="1.0"
                              step="0.1"
                              value={strength}
                              onChange={(e) => setStrength(Number(e.target.value))}
                              className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700"
                            />
                            <p className="text-xs text-muted-foreground">
                              How much the input image influences the result (0.1 = less, 1.0 = more)
                            </p>
                          </div>
                        )}

                        {/* Character Remix Specific - Style Reference Images */}
                        {models.find(m => m.id === selectedModel)?.modelId === 'ideogram/character-remix' && (
                          <div className="space-y-2">
                            <Label>Style Reference (Optional)</Label>
                            <ImageUploadBox
                              maxImages={5}
                              maxSizeMB={10}
                              uploadedFiles={styleImageFiles}
                              onFilesChange={setStyleImageFiles}
                              initialUrls={styleImageUrls}
                              onUrlsRemove={(urls) => {
                                setStyleImageUrls(urls);
                              }}
                              onUpload={async (files) => {
                                setIsStyleImageUploading(true);
                                try {
                                  const uploadPromises = files.map(async (file) => {
                                    const reader = new FileReader();
                                    const base64 = await new Promise<string>((resolve) => {
                                      reader.onloadend = () => {
                                        const result = reader.result as string;
                                        resolve(result.split(',')[1]);
                                      };
                                      reader.readAsDataURL(file);
                                    });
                                    
                                    const result = await uploadMutation.mutateAsync({
                                      file: base64,
                                      filename: file.name,
                                      contentType: file.type,
                                    });
                                    
                                    return result.url;
                                  });

                                  const urls = await Promise.all(uploadPromises);
                                  setStyleImageUrls(urls);
                                  return urls;
                                } finally {
                                  setIsStyleImageUploading(false);
                                }
                              }}
                              isUploading={isStyleImageUploading}
                              label="Upload Style References"
                              description="Optional: Upload images to guide the style"
                            />
                          </div>
                        )}
                      </>
                    )}

                    <Button
                      onClick={handleGenerate}
                      disabled={createMutation.isPending || !selectedModel || !prompt.trim()}
                      className="w-full"
                    >
                      {createMutation.isPending ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Generating...
                        </>
                      ) : (
                        <>
                          <Sparkles className="mr-2 h-4 w-4" />
                          Generate Image
                          {selectedModel && models.find(m => m.id === selectedModel) && (() => {
                            const model = models.find(m => m.id === selectedModel);
                            let cost = model?.costPerGeneration || 0;
                            
                            // Calculate actual cost based on parameters
                            if (model?.modelId.startsWith('ideogram/')) {
                              // Get cost from pricingOptions based on rendering_speed
                              if (renderingSpeed && model.pricingOptions) {
                                try {
                                  const pricingOptions = JSON.parse(model.pricingOptions);
                                  if (pricingOptions[renderingSpeed]) {
                                    cost = pricingOptions[renderingSpeed];
                                  }
                                } catch (e) {
                                  console.error('[Pricing] Failed to parse pricingOptions:', e);
                                }
                              }
                              const numImagesInt = parseInt(numImages);
                              cost = cost * numImagesInt;
                            } else if (model?.modelId.startsWith('bytedance/seedream-v4')) {
                              cost = cost * maxImages;
                            }
                            
                            return (
                              <span className="ml-2 text-xs opacity-80">
                                ({cost} credits)
                              </span>
                            );
                          })()}
                        </>
                      )}
                    </Button>
                  </CardContent>
                </Card>
            )}

            {/* Video Generator */}
            {currentTab === "video" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Generate Video</CardTitle>
                    <CardDescription>
                      Create stunning videos with AI
                    </CardDescription>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    {/* Video Sub-tabs */}
                    <Tabs value={videoSubTab} onValueChange={setVideoSubTab} className="w-full">
                      <TabsList className="grid w-full grid-cols-3">
                        <TabsTrigger value="sora2">Sora 2</TabsTrigger>
                        <TabsTrigger value="veo">Veo 3.1</TabsTrigger>
                        <TabsTrigger value="seedance">Seedance</TabsTrigger>
                      </TabsList>

                      {/* Sora 2 Sub-tab */}
                      <TabsContent value="sora2" className="space-y-4 mt-4">
                        <Sora2Tab
                          models={models}
                          credits={credits}
                          prompt={prompt}
                          setPrompt={setPrompt}
                          selectedModel={sora2Model}
                          setSelectedModel={(value) => {
                            setSora2Model(value);
                            setSelectedModel(value);
                          }}
                          onGenerate={(params) => {
                            createMutation.mutate(params);
                          }}
                          isGenerating={createMutation.isPending}
                        />
                      </TabsContent>

                      {/* Veo 3.1 Sub-tab */}
                      <TabsContent value="veo" className="space-y-4 mt-4">
                        <Veo3Tab
                          models={models}
                          credits={credits}
                          prompt={prompt}
                          setPrompt={setPrompt}
                          selectedModel={veoModel}
                          setSelectedModel={(value) => {
                            setVeoModel(value);
                            setSelectedModel(value);
                          }}
                          onGenerate={(params) => {
                            createMutation.mutate(params);
                          }}
                          isGenerating={createMutation.isPending}
                        />
                      </TabsContent>

                      {/* Seedance Sub-tab */}
                      <TabsContent value="seedance" className="space-y-4 mt-4">
                        <SeedanceTab
                          models={seedanceModels}
                          selectedModel={seedanceModels.find(m => m.id === seedanceModel)}
                          onModelChange={(value) => {
                            setSeedanceModel(value);
                            setSelectedModel(value);
                          }}
                          onGenerate={(params) => {
                            createMutation.mutate(params);
                          }}
                          isGenerating={createMutation.isPending}
                        />
                      </TabsContent>
                    </Tabs>
                  </CardContent>
                </Card>
            )}
            </div>

          {/* Results */}
          <div className="lg:col-span-2 space-y-4">
            {/* Header with View Size Controls */}
            <div className="flex items-center justify-between flex-wrap gap-4">
              <div className="flex items-center gap-4">
                <h2 className="text-2xl font-bold">Your Generations</h2>
                {generations.length > 0 && (
                  <span className="text-sm text-muted-foreground">
                    {generations.length} total
                  </span>
                )}
              </div>
              
              {generations.length > 0 && (
                <div className="flex items-center gap-2">
                  <span className="text-sm text-muted-foreground mr-2">View:</span>
                  <Button
                    variant={viewSize === "compact" ? "default" : "outline"}
                    size="sm"
                    onClick={() => setViewSize("compact")}
                    className="h-8 px-3"
                  >
                    <Grid3x3 className="h-4 w-4 mr-1" />
                    Compact
                  </Button>
                  <Button
                    variant={viewSize === "comfortable" ? "default" : "outline"}
                    size="sm"
                    onClick={() => setViewSize("comfortable")}
                    className="h-8 px-3"
                  >
                    <LayoutGrid className="h-4 w-4 mr-1" />
                    Comfortable
                  </Button>
                  <Button
                    variant={viewSize === "spacious" ? "default" : "outline"}
                    size="sm"
                    onClick={() => setViewSize("spacious")}
                    className="h-8 px-3"
                  >
                    <LayoutList className="h-4 w-4 mr-1" />
                    Spacious
                  </Button>
                </div>
              )}
            </div>

            {generations.length === 0 ? (
              <Card>
                <CardContent className="py-16 text-center">
                  <Sparkles className="h-16 w-16 mx-auto mb-4 text-muted-foreground opacity-50" />
                  <p className="text-lg font-medium mb-2">No generations yet</p>
                  <p className="text-muted-foreground">
                    Create your first AI-generated image or video
                  </p>
                </CardContent>
              </Card>
            ) : (
              <>
                {/* Masonry Grid */}
                <Masonry
                  breakpointCols={{
                    default: viewSize === "compact" ? 3 : viewSize === "comfortable" ? 2 : 1,
                    1024: viewSize === "compact" ? 2 : 1,
                    640: 1
                  }}
                  className="flex -ml-4 w-auto"
                  columnClassName="pl-4 bg-clip-padding"
                >
                  {[...generations]
                    .sort((a, b) => {
                      const dateA = new Date(a.createdAt || 0).getTime();
                      const dateB = new Date(b.createdAt || 0).getTime();
                      return dateB - dateA; // Newest first
                    })
                    .slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage)
                    .map((gen) => {
                      const model = models.find((m) => m.id === gen.modelId);
                      const isImage = model?.type === "image";

                      return (
                        <Card key={gen.id} className={`overflow-hidden hover:shadow-lg transition-shadow ${
                          viewSize === "compact" ? "mb-3" : viewSize === "comfortable" ? "mb-4" : "mb-6"
                        }`}>
                          <CardContent className="p-0">
                            {/* Result Display */}
                            {gen.status === "completed" && (gen.resultUrl || gen.resultUrls) && (
                              <div className="relative group">
                                {isImage ? (
                                  (() => {
                                    // Use resultUrls if available (batch generation), otherwise fallback to resultUrl
                                    let urls: string[] = [];
                                    if (gen.resultUrls) {
                                      try {
                                        urls = JSON.parse(gen.resultUrls);
                                      } catch (e) {
                                        console.error('Failed to parse resultUrls:', e);
                                        urls = gen.resultUrl ? [gen.resultUrl] : [];
                                      }
                                    } else if (gen.resultUrl) {
                                      urls = [gen.resultUrl];
                                    }

                                    // Multiple images - display in grid
                                    if (urls.length > 1) {
                                      return (
                                        <div className={`grid gap-2 p-2 ${urls.length === 2 ? 'grid-cols-2' : urls.length === 3 ? 'grid-cols-2' : 'grid-cols-2'}`}>
                                          {urls.map((url: string, idx: number) => (
                                            <div key={idx} className="relative group/img">
                                              <img
                                                src={url}
                                                alt={`${gen.prompt} - ${idx + 1}`}
                                                className="w-full h-auto rounded-lg cursor-pointer object-cover"
                                                onClick={() => handleViewImage(url, gen.prompt)}
                                              />
                                              <div className="absolute inset-0 bg-black/60 opacity-0 group-hover/img:opacity-100 transition-opacity flex items-center justify-center gap-1 rounded-lg">
                                                <Button
                                                  size="icon"
                                                  variant="secondary"
                                                  className="h-8 w-8"
                                                  onClick={() => handleViewImage(url, gen.prompt)}
                                                >
                                                  <ZoomIn className="h-3 w-3" />
                                                </Button>
                                                <Button
                                                  size="icon"
                                                  variant="secondary"
                                                  className="h-8 w-8"
                                                  asChild
                                                >
                                                  <a href={url} download target="_blank" rel="noopener noreferrer">
                                                    <Download className="h-3 w-3" />
                                                  </a>
                                                </Button>
                                              </div>
                                            </div>
                                          ))}
                                        </div>
                                      );
                                    }

                                    // Single image - display normally
                                    return (
                                      <>
                                        <img
                                          src={urls[0]}
                                          alt={gen.prompt}
                                          className="w-full object-cover cursor-pointer"
                                          style={{
                                            aspectRatio: viewSize === "compact" ? "1/1" : "auto"
                                          }}
                                          onClick={() => handleViewImage(urls[0], gen.prompt)}
                                        />
                                        <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2">
                                          <Button
                                            size="icon"
                                            variant="secondary"
                                            onClick={() => handleViewImage(urls[0], gen.prompt)}
                                          >
                                            <ZoomIn className="h-4 w-4" />
                                          </Button>
                                          <Button
                                            size="icon"
                                            variant="secondary"
                                            asChild
                                          >
                                            <a href={urls[0]} download target="_blank" rel="noopener noreferrer">
                                              <Download className="h-4 w-4" />
                                            </a>
                                          </Button>
                                          <Button
                                            size="icon"
                                            variant="secondary"
                                            onClick={() => handleShare(urls[0], gen.prompt)}
                                          >
                                            <Share2 className="h-4 w-4" />
                                          </Button>
                                        </div>
                                      </>
                                    );
                                  })()
                                ) : (
                                  <video
                                    src={gen.resultUrl || undefined}
                                    controls
                                    className="w-full aspect-video"
                                  />
                                )}
                              </div>
                            )}

                            {/* Processing State */}
                            {gen.status === "processing" && (
                              <div className="aspect-square bg-gradient-to-br from-gray-100 to-gray-200 flex items-center justify-center">
                                <div className="text-center space-y-3">
                                  <Loader2 className="h-12 w-12 animate-spin mx-auto text-primary" />
                                  <p className="text-sm font-medium">Generating...</p>
                                  <p className="text-xs text-muted-foreground">This may take a few minutes</p>
                                </div>
                              </div>
                            )}

                            {/* Pending State */}
                            {gen.status === "pending" && (
                              <div className="aspect-square bg-gradient-to-br from-blue-50 to-blue-100 flex items-center justify-center">
                                <div className="text-center space-y-3">
                                  <Loader2 className="h-12 w-12 animate-spin mx-auto text-blue-600" />
                                  <p className="text-sm font-medium">In Queue...</p>
                                </div>
                              </div>
                            )}

                            {/* Failed State */}
                            {gen.status === "failed" && (
                              <div className="aspect-square bg-gradient-to-br from-red-50 to-red-100 flex items-center justify-center">
                                <div className="text-center space-y-2 p-4">
                                  <p className="text-sm font-medium text-red-800">Generation Failed</p>
                                  {gen.errorMessage && (
                                    <p className="text-xs text-red-600">{gen.errorMessage}</p>
                                  )}
                                </div>
                              </div>
                            )}

                            {/* Info Section */}
                            <div className={`space-y-3 ${
                              viewSize === "compact" ? "p-3" : viewSize === "comfortable" ? "p-4" : "p-5"
                            }`}>
                              <div className="flex items-start justify-between gap-2">
                                <div className="flex-1 min-w-0">
                                  <p className={`font-semibold mb-1 line-clamp-2 ${
                                    viewSize === "compact" ? "text-xs" : "text-sm"
                                  }`}>{gen.prompt}</p>
                                  <div className="flex items-center gap-2 mt-2">
                                    <span className={`px-2 py-0.5 rounded-full font-medium bg-primary/10 text-primary ${
                                      viewSize === "compact" ? "text-[10px]" : "text-xs"
                                    }`}>
                                      {model?.name}
                                    </span>
                                  </div>
                                </div>
                                <div className={`px-2 py-1 rounded font-medium whitespace-nowrap ${
                                  viewSize === "compact" ? "text-[10px]" : "text-xs"
                                } ${
                                  gen.status === "completed" ? "bg-green-100 text-green-800" :
                                  gen.status === "failed" ? "bg-red-100 text-red-800" :
                                  gen.status === "processing" ? "bg-blue-100 text-blue-800" :
                                  "bg-gray-100 text-gray-800"
                                }`}>
                                  {gen.status}
                                </div>
                              </div>

                              {/* Actions */}
                              <div className="flex items-center justify-between pt-2 border-t">
                                <div className={`flex items-center gap-3 text-muted-foreground ${
                                  viewSize === "compact" ? "text-[10px]" : "text-xs"
                                }`}>
                                  <span className="flex items-center gap-1">
                                    <Coins className="h-3 w-3" />
                                    {formatCredits(gen.creditsUsed)}
                                  </span>
                                  <span>
                                    {gen.completedAt ? (
                                      <>
                                        {new Date(gen.completedAt).toLocaleDateString()}{' '}
                                        {new Date(gen.completedAt).toLocaleTimeString()}
                                        {gen.createdAt && (() => {
                                          const start = new Date(gen.createdAt).getTime();
                                          const end = new Date(gen.completedAt).getTime();
                                          const duration = Math.floor((end - start) / 1000); // seconds
                                          const minutes = Math.floor(duration / 60);
                                          const seconds = duration % 60;
                                          return ` (${minutes > 0 ? `${minutes}m ` : ''}${seconds}s)`;
                                        })()}
                                      </>
                                    ) : gen.createdAt ? (
                                      new Date(gen.createdAt).toLocaleDateString()
                                    ) : ''}
                                  </span>
                                </div>

                                <div className="flex items-center gap-1">
                                  {gen.status === "completed" && (
                                    <>
                                      {/* Get 1080P button for Veo 3.1 videos */}
                                      {(gen.modelId === "veo3" || gen.modelId === "veo3-fast") && gen.taskId && (
                                        <Button
                                          variant="ghost"
                                          size="sm"
                                          className="h-8 text-xs"
                                          onClick={() => {
                                            toast.info("Fetching 1080P version...");
                                            get1080pMutation.mutate({ taskId: gen.taskId! });
                                          }}
                                          disabled={get1080pMutation.isPending}
                                        >
                                          {get1080pMutation.isPending ? "Loading..." : "1080P"}
                                        </Button>
                                      )}
                                      <Button
                                        variant="ghost"
                                        size="icon"
                                        className="h-8 w-8"
                                        onClick={() => handleCopyPrompt(gen.prompt)}
                                      >
                                        <Copy className="h-4 w-4" />
                                      </Button>
                                      <Button
                                        variant="ghost"
                                        size="icon"
                                        className="h-8 w-8"
                                        onClick={async () => {
                                          // Load prompt
                                          setPrompt(gen.prompt);
                                          
                                          // Debug: Check model selection and parameters
                                          console.log('[Reuse] Generation:', gen);
                                          console.log('[Reuse] Parameters:', gen.parameters);
                                          const foundModel = models.find(m => m.id === gen.modelId);
                                          console.log('[Reuse] Found model:', foundModel);
                                          
                                          // Map edit models back to base models for dropdown selection
                                          // Edit models are used automatically when images are uploaded
                                          let displayModelId = gen.modelId;
                                          console.log('[Reuse] Original modelId:', gen.modelId);
                                          console.log('[Reuse] Found model:', foundModel);
                                          if (foundModel?.name) {
                                            console.log('[Reuse] Found model.name:', foundModel.name);
                                            // Remove " Edit" suffix from model name to get base model name
                                            // e.g., "Seedream V4 Edit" -> "Seedream V4"
                                            const baseName = foundModel.name.replace(/ Edit$/, '');
                                            console.log('[Reuse] Base name after replace:', baseName);
                                            // Find the base model by name
                                            const baseModel = models.find(m => m.name === baseName && m.type === foundModel.type);
                                            console.log('[Reuse] Found base model:', baseModel);
                                            if (baseModel) {
                                              displayModelId = baseModel.id;
                                              console.log('[Reuse] Mapped edit model to base model:', foundModel.name, '->', baseName, '(', displayModelId, ')');
                                            } else {
                                              console.log('[Reuse] Base model not found, using original modelId');
                                            }
                                          }
                                          console.log('[Reuse] Final displayModelId:', displayModelId);
                                          
                                          // Switch to correct tab and set the tab-specific model state
                                          if (gen.type === 'image') {
                                            setCurrentTab('image');
                                            setImageModel(displayModelId); // Use mapped base model for dropdown
                                          } else if (gen.type === 'video') {
                                            // Determine which video tab based on model
                                            const model = models.find(m => m.id === gen.modelId);
                                            if (model?.modelId?.startsWith('sora')) {
                                              setCurrentTab('sora2');
                                              setSora2Model(gen.modelId); // Set sora2Model
                                            } else if (model?.modelId?.startsWith('veo')) {
                                              setCurrentTab('veo');
                                              setVeoModel(gen.modelId); // Set veoModel
                                            } else if (model?.modelId?.startsWith('bytedance/v1')) {
                                              setCurrentTab('seedance');
                                              setSeedanceModel(gen.modelId); // Set seedanceModel
                                            }
                                          }
                                          
                                          // Load parameters if available
                                          if (gen.parameters) {
                                            try {
                                              const params = JSON.parse(gen.parameters);
                                              
                                              // Image parameters
                                              if (params.aspectRatio) setAspectRatio(params.aspectRatio);
                                              if (params.imageResolution) setImageResolution(params.imageResolution);
                                              if (params.outputFormat) setOutputFormat(params.outputFormat);
                                              if (params.maxImages) setMaxImages(params.maxImages);
                                              if (params.renderingSpeed) setRenderingSpeed(params.renderingSpeed);
                                              if (params.style) setStyle(params.style);
                                              if (params.expandPrompt !== undefined) setExpandPrompt(params.expandPrompt);
                                              if (params.numImages) setNumImages(params.numImages);
                                              if (params.strength !== undefined) setStrength(params.strength);
                                              if (params.negativePrompt) setNegativePrompt(params.negativePrompt);
                                              
                                              // Video parameters (add when video tab has state variables)
                                              
                                              // Reuse URLs directly from S3 storage (no need to download + re-upload)
                                              // This saves bandwidth and is much faster
                                              
                                              // Load imageUrl (for Character Remix, single image)
                                              if (params.imageUrl) {
                                                console.log('[Reuse] Setting imageUrl:', params.imageUrl);
                                                setImageUrl(params.imageUrl);
                                                setImageUploadFiles([]); // Clear files since we're using URL
                                              }
                                              
                                              // Load imageUrls (for image editing models like Seedream V4 Edit)
                                              console.log('[Reuse] Checking params.imageUrls:', params.imageUrls);
                                              if (params.imageUrls && params.imageUrls.length > 0) {
                                                console.log('[Reuse] Setting imageUrl from imageUrls[0]:', params.imageUrls[0]);
                                                // For editing models, imageUrls should be loaded into the appropriate upload field
                                                // This depends on the model - for Seedream V4 Edit, it uses imageUrls
                                                setImageUrl(params.imageUrls[0]); // Use first image
                                                setImageUploadFiles([]); // Clear files since we're using URL
                                                console.log('[Reuse] imageUrl should now be:', params.imageUrls[0]);
                                              } else {
                                                console.log('[Reuse] No imageUrls found in parameters');
                                              }
                                              
                                              // Load character reference URLs directly
                                              console.log('[Reuse] referenceImageUrls from params:', params.referenceImageUrls);
                                              if (params.referenceImageUrls && params.referenceImageUrls.length > 0) {
                                                console.log('[Reuse] Setting referenceImageUrls:', params.referenceImageUrls);
                                                setReferenceImageUrls(params.referenceImageUrls);
                                                setReferenceImageFiles([]); // Clear files since we're using URLs
                                              } else {
                                                console.log('[Reuse] No referenceImageUrls found in parameters');
                                              }
                                              
                                              // Load style reference URLs directly
                                              if (params.styleImageUrls && params.styleImageUrls.length > 0) {
                                                setStyleImageUrls(params.styleImageUrls);
                                                setStyleImageFiles([]); // Clear files since we're using URLs
                                              }
                                              
                                              toast.success("Prompt, settings, and reference images loaded!");
                                            } catch (e) {
                                              console.error('Failed to parse parameters:', e);
                                              toast.success("Prompt loaded");
                                            }
                                          } else {
                                            toast.success("Prompt loaded");
                                          }
                                        }}
                                      >
                                        <RefreshCw className="h-4 w-4" />
                                      </Button>
                                    </>
                                  )}
                                  <Button
                                    variant="ghost"
                                    size="icon"
                                    className="h-8 w-8"
                                    onClick={() => deleteMutation.mutate({ id: gen.id })}
                                    disabled={deleteMutation.isPending}
                                  >
                                    <Trash2 className="h-4 w-4 text-destructive" />
                                  </Button>
                                </div>
                              </div>
                            </div>
                          </CardContent>
                        </Card>
                      );
                    })}
                </Masonry>

                {/* Pagination */}
                {generations.length > itemsPerPage && (
                  <div className="flex items-center justify-center gap-2 pt-4">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                      disabled={currentPage === 1}
                    >
                      <ChevronLeft className="h-4 w-4 mr-1" />
                      Previous
                    </Button>
                    <div className="flex items-center gap-2">
                      {Array.from({ length: Math.ceil(generations.length / itemsPerPage) }, (_, i) => i + 1)
                        .filter(page => {
                          const totalPages = Math.ceil(generations.length / itemsPerPage);
                          if (totalPages <= 7) return true;
                          if (page === 1 || page === totalPages) return true;
                          if (page >= currentPage - 1 && page <= currentPage + 1) return true;
                          return false;
                        })
                        .map((page, index, array) => {
                          const showEllipsis = index > 0 && page - array[index - 1] > 1;
                          return (
                            <div key={page} className="flex items-center gap-2">
                              {showEllipsis && <span className="text-muted-foreground">...</span>}
                              <Button
                                variant={currentPage === page ? "default" : "outline"}
                                size="sm"
                                onClick={() => setCurrentPage(page)}
                                className="h-8 w-8 p-0"
                              >
                                {page}
                              </Button>
                            </div>
                          );
                        })}
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(p => Math.min(Math.ceil(generations.length / itemsPerPage), p + 1))}
                      disabled={currentPage >= Math.ceil(generations.length / itemsPerPage)}
                    >
                      Next
                      <ChevronRight className="h-4 w-4 ml-1" />
                    </Button>
                  </div>
                )}
              </>
            )}
          </div>
        </div>
      </div>

        {/* Image Viewer */}
        <ImageViewer
          src={viewerImage.src}
          alt={viewerImage.alt}
          open={viewerOpen}
          onOpenChange={setViewerOpen}
        />
      </div>
    </div>
  );
}

